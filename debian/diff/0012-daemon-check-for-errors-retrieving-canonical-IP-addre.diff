From f590765b2f1b733d2345453d328cce8c7e99b6be Mon Sep 17 00:00:00 2001
From: Jonathan Nieder <jrnieder@gmail.com>
Date: Fri, 17 Jun 2011 05:26:05 -0500
Subject: daemon: check for errors retrieving canonical IP address

To convert a resolver result to an IP address for interpolation
in the --interpolated-path=...%IP... feature, currently the
git daemon calls inet_ntop to fill a buffer of size HOST_NAME_MAX + 1
and copies it, ignoring errors.  That has a few problems:

 - there is no principled reason for the buffer to have size
   HOST_NAME_MAX (which can be as small as 8).
 - when an error occurs, this means copying a possibly uninitialized
   buffer.

Fix them:

 - in the ipv4 code path, make the buffer size INET6_ADDRSTRLEN (the
   maximum size of an ipv6 address string), falling back to
   INET_ADDRSTRLEN if the build system is ignorant about the size of
   ipv6 addresses.

 - in the ipv6 codepath, use getnameinfo to write the numeric address
   string, since it is a little more convenient and already used
   elsewhere.  The buffer to receive the result is of size NI_MAXHOST.

 - return NULL on error.  strbuf_expand_dict_cb treats NULL as an
   empty substitution string.

Signed-off-by: Jonathan Nieder <jrnieder@gmail.com>
---
 dns-ipv4.h |   13 ++++++++-----
 dns-ipv6.c |   16 ++++++++--------
 tcp.c      |    6 ++++--
 3 files changed, 20 insertions(+), 15 deletions(-)

diff --git a/dns-ipv4.h b/dns-ipv4.h
index 4d03d9c..9e6f590 100644
--- a/dns-ipv4.h
+++ b/dns-ipv4.h
@@ -1,8 +1,10 @@
 #ifndef DNS_IPV4_H
 #define DNS_IPV4_H
 
-#ifndef HOST_NAME_MAX
-#define HOST_NAME_MAX 256
+#ifdef INET6_ADDRSTRLEN
+#define ADDRBUFLEN INET6_ADDRSTRLEN
+#else
+#define ADDRBUFLEN INET_ADDRSTRLEN
 #endif
 
 struct ipv4_address {
@@ -33,9 +35,10 @@ static inline const char *dns_name(const resolved_address *addr)
 static inline char *dns_ip_address(const resolved_address *addr,
 					const resolver_result *ai)
 {
-	char addrbuf[HOST_NAME_MAX + 1];
-	inet_ntop(ai->he->h_addrtype, &addr->sa.sin_addr,
-		  addrbuf, sizeof(addrbuf));
+	char addrbuf[ADDRBUFLEN];
+	if (!inet_ntop(ai->he->h_addrtype, &addr->sa.sin_addr,
+		  addrbuf, sizeof(addrbuf)))
+		return NULL;
 	return xstrdup(addrbuf);
 }
 
diff --git a/dns-ipv6.c b/dns-ipv6.c
index f446ba1..dcfeac4 100644
--- a/dns-ipv6.c
+++ b/dns-ipv6.c
@@ -1,8 +1,9 @@
 #include "cache.h"
 #include "dns-ipv6.h"
 
-#ifndef HOST_NAME_MAX
-#define HOST_NAME_MAX 256
+/* from RFC 2553 */
+#ifndef NI_MAXHOST
+#define NI_MAXHOST 1025
 #endif
 
 const char *dns_name(const resolved_address *i)
@@ -19,12 +20,11 @@ const char *dns_name(const resolved_address *i)
 char *dns_ip_address(const resolved_address *i, const resolver_result *ai0)
 {
 	const struct addrinfo *ai = *i;
-	char addrbuf[HOST_NAME_MAX + 1];
-	struct sockaddr_in *sin_addr;
-
-	sin_addr = (void *)ai->ai_addr;
-	inet_ntop(AF_INET, &sin_addr->sin_addr, addrbuf, sizeof(addrbuf));
-	return xstrdup(addrbuf);
+	char addr[NI_MAXHOST];
+	if (getnameinfo(ai->ai_addr, ai->ai_addrlen, addr, sizeof(addr),
+			NULL, 0, NI_NUMERICHOST))
+		return NULL;
+	return xstrdup(addr);
 }
 
 int dns_resolve(const char *host, const char *port, int flags,
diff --git a/tcp.c b/tcp.c
index aacc2d1..2707c49 100644
--- a/tcp.c
+++ b/tcp.c
@@ -106,8 +106,10 @@ void git_locate_host(const char *hostname, char **ip_address,
 		*ip_address = dns_ip_address(&i, &ai);
 
 		free(*canon_hostname);
-		*canon_hostname = xstrdup(dns_canonname(i, ai) ?
-					dns_canonname(i, ai) : *ip_address);
+		*canon_hostname =
+			dns_canonname(i, ai) ? xstrdup(dns_canonname(i, ai)) :
+			*ip_address ? xstrdup(*ip_address) :
+			NULL;
 		break;
 	}
 
-- 
1.7.6.rc1

