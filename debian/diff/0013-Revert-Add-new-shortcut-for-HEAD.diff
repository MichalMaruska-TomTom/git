From a5f003af5bc7a34c64e36ad0a9ed88943c120c44 Mon Sep 17 00:00:00 2001
From: Junio C Hamano <gitster@pobox.com>
Date: Wed, 14 Aug 2013 10:57:24 -0700
Subject: Revert "Add new @ shortcut for HEAD"

commit 2c2b6646c2723459dbd334c7ced6f77ffb0d596e upstream.

This reverts commit cdfd94837b27c220f70f032b596ea993d195488f, as it
does not just apply to "@" (and forms with modifiers like @{u}
applied to it), but also affects e.g. "refs/heads/@/foo", which it
shouldn't.

The basic idea of giving a short-hand might be good, and the topic
can be retried later, but let's revert to avoid affecting existing
use cases for now for the upcoming release.

Signed-off-by: Jonathan Nieder <jrnieder@gmail.com>
---
 Documentation/git-check-ref-format.txt |  2 --
 Documentation/revisions.txt            |  3 ---
 refs.c                                 |  4 ----
 sha1_name.c                            | 17 -----------------
 t/t1508-at-combinations.sh             |  2 --
 5 files changed, 28 deletions(-)

diff --git a/Documentation/git-check-ref-format.txt b/Documentation/git-check-ref-format.txt
index fc02959..a49be1b 100644
--- a/Documentation/git-check-ref-format.txt
+++ b/Documentation/git-check-ref-format.txt
@@ -54,8 +54,6 @@ Git imposes the following rules on how references are named:
 
 . They cannot contain a sequence `@{`.
 
-. They cannot be the single character `@`.
-
 . They cannot contain a `\`.
 
 These rules make it easy for shell script based tools to parse
diff --git a/Documentation/revisions.txt b/Documentation/revisions.txt
index 09896a3..d477b3f 100644
--- a/Documentation/revisions.txt
+++ b/Documentation/revisions.txt
@@ -58,9 +58,6 @@ the '$GIT_DIR/refs' directory or from the '$GIT_DIR/packed-refs' file.
 While the ref name encoding is unspecified, UTF-8 is preferred as
 some output processing may assume ref names in UTF-8.
 
-'@'::
-  '@' alone is a shortcut for 'HEAD'.
-
 '<refname>@\{<date>\}', e.g. 'master@\{yesterday\}', 'HEAD@\{5 minutes ago\}'::
   A ref followed by the suffix '@' with a date specification
   enclosed in a brace
diff --git a/refs.c b/refs.c
index 7b08a37..7922261 100644
--- a/refs.c
+++ b/refs.c
@@ -72,10 +72,6 @@ int check_refname_format(const char *refname, int flags)
 {
 	int component_len, component_count = 0;
 
-	if (!strcmp(refname, "@"))
-		/* Refname is a single character '@'. */
-		return -1;
-
 	while (1) {
 		/* We are at the start of a path component. */
 		component_len = check_refname_component(refname, flags);
diff --git a/sha1_name.c b/sha1_name.c
index 852dd95..65ad066 100644
--- a/sha1_name.c
+++ b/sha1_name.c
@@ -1004,17 +1004,6 @@ int get_sha1_mb(const char *name, unsigned char *sha1)
 	return st;
 }
 
-/* parse @something syntax, when 'something' is not {.*} */
-static int interpret_empty_at(const char *name, int namelen, int len, struct strbuf *buf)
-{
-	if (len || name[1] == '{')
-		return -1;
-
-	strbuf_reset(buf);
-	strbuf_add(buf, "HEAD", 4);
-	return 1;
-}
-
 static int reinterpret(const char *name, int namelen, int len, struct strbuf *buf)
 {
 	/* we have extra data, which might need further processing */
@@ -1077,15 +1066,9 @@ int interpret_branch_name(const char *name, struct strbuf *buf)
 	cp = strchr(name, '@');
 	if (!cp)
 		return -1;
-
-	len = interpret_empty_at(name, namelen, cp - name, buf);
-	if (len > 0)
-		return reinterpret(name, namelen, len, buf);
-
 	tmp_len = upstream_mark(cp, namelen - (cp - name));
 	if (!tmp_len)
 		return -1;
-
 	len = cp + tmp_len - name;
 	cp = xstrndup(name, cp - name);
 	upstream = branch_get(*cp ? cp : NULL);
diff --git a/t/t1508-at-combinations.sh b/t/t1508-at-combinations.sh
index 4db1613..e5aea3b 100755
--- a/t/t1508-at-combinations.sh
+++ b/t/t1508-at-combinations.sh
@@ -55,8 +55,6 @@ check "HEAD@{u}" ref refs/heads/upstream-branch
 check "@{u}@{1}" commit upstream-one
 check "@{-1}@{u}" ref refs/heads/master
 check "@{-1}@{u}@{1}" commit master-one
-check "@" commit new-two
-check "@@{u}" ref refs/heads/upstream-branch
 nonsense "@{u}@{-1}"
 nonsense "@{0}@{0}"
 nonsense "@{1}@{u}"
-- 
1.8.4.rc2

